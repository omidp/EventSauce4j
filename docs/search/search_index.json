{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to EventSauce4j","text":"<p><code>eventsauce4j</code> is a lightweight event sourcing toolkit for Java + Spring Framework, inspired by EventSauce (PHP). It provides clean building blocks for domain events, message repositories, dispatching, outbox, with a persistence module.</p> <p>If you know EventSauce in PHP, you should feel at home: the vocabulary, responsibilities, and flow are intentionally adapted to Java idioms.</p>"},{"location":"#why-eventsauce4j","title":"Why EventSauce4j?","text":"<p>Event sourcing is a powerful architectural pattern, but many existing libraries are large, opinionated, or hard to integrate with. The goals of eventsauce4j are:</p> <ul> <li>Minimal footprint, easy to embed in Spring / Spring Boot</li> <li>Pluggable persistence / transport / serialization</li> <li>A pragmatic event sourcing library for Spring framework with a focus on developer experience.</li> </ul>"},{"location":"#modules","title":"Modules","text":"Module Description eventsauce4j-core Synchronous implementation of the message dispatcher and core event sourcing components. eventsauce4j-jpa JPA-based implementation of the Outbox pattern for reliable event persistence and publication. eventsauce4j-rabbitmq RabbitMQ producer and consumer support for inter-service event communication. eventsauce4j-jackson JSON event serialization and deserialization using Jackson."},{"location":"#core-concepts","title":"Core Concepts","text":"<p>This section introduces the fundamental building blocks of eventsauce4j and explains how they interact to support event-sourced applications in Java and Spring.</p>"},{"location":"#message-decoration","title":"\ud83d\udce8 Message Decoration","text":"<p>EventSauce4j allows message decoration, meaning you can attach additional metadata (headers) to your messages. This is useful for adding contextual information before a message is persisted or dispatched, such as correlation IDs, tenant identifiers, or trace information.</p>"},{"location":"#event-dispatcher","title":"\u26a1 Event Dispatcher","text":"<p>Events are a central concept in event sourcing, but they\u2019re also valuable beyond it. An event dispatcher decouples systems by propagating events to subscribers, enabling clean separation between write and read models or between microservices.</p> <p>In eventsauce4j, the event dispatcher ensures that domain events flow seamlessly from your aggregates to handlers or external systems.</p>"},{"location":"#message-dispatcher","title":"\ud83e\udded Message Dispatcher","text":"<p>The message dispatcher is responsible for sending messages to registered <code>MessageConsumers</code>. It defines how events are actually delivered synchronously or asynchronously depending on the module in use.</p> <p>Custom Dispatchers</p> <p>You can implement your own message dispatcher by implementing the <code>MessageDispatcher</code> interface.</p>"},{"location":"#inflector","title":"\ud83d\udd24 Inflector","text":"<p>An Inflector converts event class names into string identifiers when storing events. When reconstructing events, it performs the reverse: mapping the stored string back to the correct fully-qualified class name.</p> <p>This mechanism supports cross-service communication and event versioning.</p> <p>How It Works</p> <p>The Inflector composes your event type mappings using several strategies:</p> <ul> <li>ExternalInflector \u2014 maps external event packages</li> <li>AnnotationInflector \u2014 maps annotated event classes</li> <li>StaticInflector \u2014 defines explicit key-to-class mappings</li> </ul> <p>Example: Cross-Service Event Mapping</p> <p>When dispatching a <code>UserCreated</code> event from user-service to payment-service via <code>RabbitMqMessageDispatcher</code>, the consumer service must know how to deserialize it to its local event type. You can define this mapping as follows:</p> <pre><code>new StaticInflector(Map.of(\n  \"payment.public.userCreated\", PaymentUserCreated.class\n));\n</code></pre>"},{"location":"#message-serializer","title":"\ud83e\udde9 Message Serializer","text":"<p>The message serializer is responsible for converting messages to and from serialized formats for persistence or transport. When implementing a custom message repository, you\u2019ll typically use this interface.</p> <p>By default, eventsauce4j provides an jackson-based serializer, but you can easily implement your own strategy (e.g., JSON, Avro, Protobuf) to fit your infrastructure.</p>"},{"location":"#outbox","title":"\ud83d\uddc3\ufe0f Outbox","text":"<p>The Outbox pattern ensures that event persistence and dispatching occur atomically, either both succeed or both fail.</p> <p>Why It Matters</p> <p>Without an outbox, persisting domain changes and dispatching events involve two separate network operations. If one fails, inconsistencies can occur.</p> <p>The transactional outbox buffers events in a dedicated database table before dispatching them asynchronously. Although this adds slight latency, it guarantees at-least-once delivery and ensures that only persisted events are published to consumers.</p>"},{"location":"#outbox-lock","title":"\ud83d\udd12 Outbox Lock","text":"<p>In horizontally scaled Spring Boot applications (multiple instances of the same service), it\u2019s crucial to prevent duplicate event consumption.</p> <p>EventSauce4j uses an outbox lock mechanism so that only one instance at a time processes pending events from the outbox table. This ensures consistent, non-duplicated event delivery across your service cluster.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#modules-in-this-guide","title":"Modules in this guide","text":"<p><code>eventsauce4j-jpa-starter</code> : JPA outbox + synchronous dispatch</p> <p><code>eventsauce4j-rabbitmq-starter</code> : RabbitMQ producer/consumer integration</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 17+</li> <li>Spring Boot (recommended)</li> <li>Maven</li> <li>Postgres</li> <li>(For RabbitMQ starter) a running RabbitMQ broker</li> </ul>"},{"location":"getting-started/#1-jpa-starter","title":"1) JPA Starter","text":""},{"location":"getting-started/#11-add-the-dependency","title":"1.1 Add the dependency","text":"<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.eventsauce4j&lt;/groupId&gt;\n  &lt;artifactId&gt;eventsauce4j-jpa-starter&lt;/artifactId&gt;\n  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"getting-started/#12-enable-the-starter","title":"1.2 Enable the starter","text":"<pre><code>import io.eventsauce4j.starter.jpa.EnableJpaEventSauce4j;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@EnableJpaEventSauce4j\npublic class Config {\n\n  @Bean\n  Inflector inflection() {\n    return new ChainInflector(List.of(\n      new ExternalInflector(\"io.eventsauce4j.example.domain.event.external\"),\n      new AnnotationInflector(UserCreated.class.getPackageName()),\n      new StaticInflector(Map.of(\n        EmailSent.class.getName(), EmailSent.class\n      ))\n    ));\n  }\n}\n</code></pre>"},{"location":"getting-started/#2-rabbitmq-starter","title":"2) RabbitMQ Starter","text":""},{"location":"getting-started/#21-add-the-dependency","title":"2.1 Add the dependency","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.eventsauce4j&lt;/groupId&gt;\n    &lt;artifactId&gt;eventsauce4j-rabbitmq-starter&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"getting-started/#22-enable-the-starter","title":"2.2 Enable the starter","text":"<pre><code>import io.eventsauce4j.starter.rabbitmq.EnableRabbitMqEventSauce4j;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@EnableRabbitMqEventSauce4j\npublic class Config {\n\n  @Bean\n  Inflector inflection() {\n    return new ChainInflector(List.of(\n      new ExternalInflector(\"io.eventsauce4j.example.domain.event.external\"),\n      new AnnotationInflector(UserCreated.class.getPackageName()),\n      new StaticInflector(Map.of(\n        EmailSent.class.getName(), EmailSent.class\n      ))\n    ));\n  }\n}\n</code></pre>"},{"location":"getting-started/#3-start-rabbitmq-for-rabbitmq-starter","title":"3) Start RabbitMQ (for RabbitMQ starter)","text":"<p>Run a local broker with Docker:</p> <pre><code>docker run -d --name rabbitmq \\\n  -p 5672:5672 -p 15672:15672 \\\n  -e RABBITMQ_DEFAULT_USER=guest \\\n  -e RABBITMQ_DEFAULT_PASS=guest \\\n  rabbitmq:3.13-management\n</code></pre> <p>Management UI: http://localhost:15672 (user/pass guest).</p>"},{"location":"getting-started/#4-configuration","title":"4) Configuration","text":"<p>RabbitMQ settings (application.yml)</p> <pre><code>eventsauce4j:\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n    exchange: eventsauce4j.exchange\n    routingKey: eventsauce4j.key\n</code></pre>"},{"location":"getting-started/#outbox-settings","title":"Outbox settings","text":"<p>Use Spring properties to tune outbox publishing:</p> <p><code>eventsauce4j.outbox.delayInterval</code> : delay between outbox publish cycles</p> <p><code>eventsauce4j.outbox.lockName</code> : lock name to isolate publishers per service</p> <p>Example:</p> <pre><code>eventsauce4j:\n  outbox:\n    delayInterval: 5 #seconds\n    lockName: user-service-outbox-lock\n</code></pre>"},{"location":"getting-started/#working-example","title":"Working Example","text":"<p>See eventsauce4j-example: two Spring Boot services (user-service and payment-service) demonstrating JPA outbox + RabbitMQ messaging and shared event mappings.</p>"},{"location":"getting-started/#database-schema-setup-postgresql","title":"Database Schema Setup (PostgreSQL)","text":"<p>When using the JPA Outbox Starter, eventsauce4j relies on a set of tables to persist and publish events. You\u2019ll find a ready-to-use SQL script named schema.sql in the project.</p> <p>Alternatively, you can configure Hibernate to automatically generate the tables for you.</p> <p>This script defines the required tables for PostgreSQL, including:</p> <p>Event Store table / Outbox table : to persist domain events and manage pending events for dispatch</p> <p>Lock table : to prevent duplicate event consumption in distributed environments</p>"},{"location":"tutorial/","title":"Tutorial Creating, Dispatching, and Consuming Events in eventsauce4j","text":"<p>This tutorial walks you through the core workflow of creating, dispatching, and consuming events using eventsauce4j.</p>"},{"location":"tutorial/#how-to-create-an-event","title":"\ud83d\udce6 How to Create an Event","text":"<p>In eventsauce4j, events represent changes that occurred in your domain. There are two main types of events:</p> <ul> <li>Private (Internal) Events \u2014 used only within the domain.</li> <li>Public Events \u2014 used for inter-service communication via messaging (e.g., RabbitMQ).</li> </ul>"},{"location":"tutorial/#private-or-internal-events","title":"\ud83e\udde9 Private or Internal Events","text":"<p>Private or internal events are meant to be consumed only inside the same domain or service. These events typically model internal state transitions and are not published externally.</p> <p>You can define an internal event in one of two ways:</p>"},{"location":"tutorial/#option-1-using-event-annotation","title":"Option 1 \u2014 Using <code>@Event</code> Annotation","text":"<p>The simplest way is to annotate your event with <code>@Event</code>. Optionally, you can specify a routing key if you use annotation-based inflection.</p> <pre><code>@Event\npublic record UserCreated(UUID id, String description) {\n}\n</code></pre>"},{"location":"tutorial/#option-2-using-staticinflector","title":"Option 2 \u2014 Using StaticInflector","text":"<p>If you prefer not to annotate your events, you can define explicit mappings in your configuration using <code>StaticInflector</code>.</p> <p>Example configuration snippet:</p> <pre><code>@Bean\nInflector inflection() {\n    return new StaticInflector(Map.of(\n        \"user.internal.userCreated\", UserCreated.class\n    ));\n}\n</code></pre>"},{"location":"tutorial/#public-events","title":"\ud83c\udf0d Public Events","text":"<p>Public events are used for cross-service communication (e.g., between <code>user-service</code> and <code>payment-service</code>). They must include a routing key, which determines how they\u2019re routed in the message broker (RabbitMQ).</p> <p>Example:</p> <pre><code>@ExternalEvent(routingKey = \"payment.public.userCreated\")\npublic record UserCreated(UUID id, String description) {\n}\n</code></pre> <p>\ud83d\udcdd Note: The routingKey ensures that other services (like payment-service) can consume and deserialize the event properly using their own inflector mappings.</p>"},{"location":"tutorial/#how-to-dispatch-an-event","title":"\ud83d\ude80 How to Dispatch an Event","text":"<p>Once your event is defined, you can dispatch it using the <code>EventDispatcher</code>.</p> <p>Inject the dispatcher into your service or aggregate and call <code>dispatch()</code>:</p> <pre><code>@Service\npublic class UserService {\n\n    private final EventDispatcher eventDispatcher;\n\n    public UserService(EventDispatcher eventDispatcher) {\n        this.eventDispatcher = eventDispatcher;\n    }\n\n    public void createUser() {\n        eventDispatcher.dispatch(\n            new UserCreated(UUID.randomUUID(), \"user created.\")\n        );\n    }\n}\n</code></pre>"},{"location":"tutorial/#how-to-consume-an-event","title":"\ud83c\udfa7 How to Consume an Event","text":"<p>To handle incoming events, implement a consumer class and annotate it with <code>@Consumer</code>.</p> <p>Consumers must implement the <code>MessageConsumer</code> interface and override the <code>handle(Message message)</code> method.</p> <p>Example:</p> <pre><code>@Consumer\npublic class UserConsumer implements MessageConsumer {\n\n    private static final Logger log = LoggerFactory.getLogger(UserConsumer.class);\n\n    @Override\n    public void handle(Message message) {\n        if (message.getEvent() instanceof UserCreated uc) {\n            log.info(\"User created: {}\", uc);\n            // Your business logic here\n        }\n    }\n}\n</code></pre> <p>You can define multiple consumers, and each will receive all messages.</p>"}]}