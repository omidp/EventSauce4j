{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to EventSauce4j","text":"<p><code>eventsauce4j</code> is a lightweight event sourcing toolkit for Java + Spring Framework, inspired by EventSauce (PHP). It provides clean building blocks for domain events, message repositories, dispatching, outbox, with a persistence module.</p> <p>If you know EventSauce in PHP, you should feel at home: the vocabulary, responsibilities, and flow are intentionally adapted to Java idioms.</p>"},{"location":"#why-eventsauce4j","title":"Why EventSauce4j?","text":"<p>Event sourcing is a powerful architectural pattern, but many existing libraries are large, opinionated, or hard to integrate with. The goals of eventsauce4j are:</p> <ul> <li>Minimal footprint, easy to embed in Spring / Spring Boot</li> <li>Pluggable persistence / transport / serialization</li> <li>A pragmatic event sourcing library for Spring framework with a focus on developer experience.</li> </ul>"},{"location":"#modules","title":"Modules","text":"Module Description eventsauce4j-core Synchronous implementation of the message dispatcher and core event sourcing components. eventsauce4j-jpa JPA-based implementation of the Outbox pattern for reliable event persistence and publication. eventsauce4j-rabbitmq RabbitMQ producer and consumer support for inter-service event communication. eventsauce4j-jackson JSON event serialization and deserialization using Jackson."},{"location":"#core-concepts","title":"Core Concepts","text":"<p>This section introduces the fundamental building blocks of eventsauce4j and explains how they interact to support event-sourced applications in Java and Spring.</p>"},{"location":"#message-decoration","title":"\ud83d\udce8 Message Decoration","text":"<p>EventSauce4j allows message decoration, meaning you can attach additional metadata (headers) to your messages. This is useful for adding contextual information before a message is persisted or dispatched, such as correlation IDs, tenant identifiers, or trace information.</p>"},{"location":"#event-dispatcher","title":"\u26a1 Event Dispatcher","text":"<p>Events are a central concept in event sourcing, but they\u2019re also valuable beyond it. An event dispatcher decouples systems by propagating events to subscribers, enabling clean separation between write and read models or between microservices.</p> <p>In eventsauce4j, the event dispatcher ensures that domain events flow seamlessly from your aggregates to handlers or external systems.</p>"},{"location":"#message-dispatcher","title":"\ud83e\udded Message Dispatcher","text":"<p>The message dispatcher is responsible for sending messages to registered <code>MessageConsumers</code>. It defines how events are actually delivered synchronously or asynchronously depending on the module in use.</p> <p>Custom Dispatchers</p> <p>You can implement your own message dispatcher by implementing the <code>MessageDispatcher</code> interface.</p>"},{"location":"#inflector","title":"\ud83d\udd24 Inflector","text":"<p>An Inflector converts event class names into string identifiers when storing events. When reconstructing events, it performs the reverse: mapping the stored string back to the correct fully-qualified class name.</p> <p>This mechanism supports cross-service communication and event versioning.</p> <p>How It Works</p> <p>The Inflector composes your event type mappings using several strategies:</p> <ul> <li>ExternalInflector \u2014 maps external event packages</li> <li>AnnotationInflector \u2014 maps annotated event classes</li> <li>StaticInflector \u2014 defines explicit key-to-class mappings</li> </ul> <p>Example: Cross-Service Event Mapping</p> <p>When dispatching a <code>UserCreated</code> event from user-service to payment-service via <code>RabbitMqMessageDispatcher</code>, the consumer service must know how to deserialize it to its local event type. You can define this mapping as follows:</p> <pre><code>new StaticInflector(Map.of(\n  \"payment.public.userCreated\", PaymentUserCreated.class\n));\n</code></pre>"},{"location":"#message-serializer","title":"\ud83e\udde9 Message Serializer","text":"<p>The message serializer is responsible for converting messages to and from serialized formats for persistence or transport. When implementing a custom message repository, you\u2019ll typically use this interface.</p> <p>By default, eventsauce4j provides an jackson-based serializer, but you can easily implement your own strategy (e.g., JSON, Avro, Protobuf) to fit your infrastructure.</p>"},{"location":"#outbox","title":"\ud83d\uddc3\ufe0f Outbox","text":"<p>The Outbox pattern ensures that event persistence and dispatching occur atomically, either both succeed or both fail.</p> <p>Why It Matters</p> <p>Without an outbox, persisting domain changes and dispatching events involve two separate network operations. If one fails, inconsistencies can occur.</p> <p>The transactional outbox buffers events in a dedicated database table before dispatching them asynchronously. Although this adds slight latency, it guarantees at-least-once delivery and ensures that only persisted events are published to consumers.</p>"},{"location":"#outbox-lock","title":"\ud83d\udd12 Outbox Lock","text":"<p>In horizontally scaled Spring Boot applications (multiple instances of the same service), it\u2019s crucial to prevent duplicate event consumption.</p> <p>EventSauce4j uses an outbox lock mechanism so that only one instance at a time processes pending events from the outbox table. This ensures consistent, non-duplicated event delivery across your service cluster.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#modules-in-this-guide","title":"Modules in this guide","text":"<p><code>eventsauce4j-jpa-starter</code> : JPA outbox + synchronous dispatch</p> <p><code>eventsauce4j-rabbitmq-starter</code> : RabbitMQ producer/consumer integration</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 17+</li> <li>Spring Boot (recommended)</li> <li>Maven</li> <li>(For RabbitMQ starter) a running RabbitMQ broker</li> </ul>"},{"location":"getting-started/#1-jpa-starter","title":"1) JPA Starter","text":""},{"location":"getting-started/#11-add-the-dependency","title":"1.1 Add the dependency","text":"<pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;io.eventsauce4j&lt;/groupId&gt;\n  &lt;artifactId&gt;eventsauce4j-jpa-starter&lt;/artifactId&gt;\n  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"getting-started/#12-enable-the-starter","title":"1.2 Enable the starter","text":"<pre><code>import io.eventsauce4j.starter.jpa.EnableJpaEventSauce4j;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@EnableJpaEventSauce4j\npublic class Config {\n\n  @Bean\n  Inflector inflection() {\n    return new ChainInflector(List.of(\n      new ExternalInflector(\"io.eventsauce4j.example.domain.event.external\"),\n      new AnnotationInflector(UserCreated.class.getPackageName()),\n      new StaticInflector(Map.of(\n        EmailSent.class.getName(), EmailSent.class\n      ))\n    ));\n  }\n}\n</code></pre>"},{"location":"getting-started/#2-rabbitmq-starter","title":"2) RabbitMQ Starter","text":""},{"location":"getting-started/#21-add-the-dependency","title":"2.1 Add the dependency","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.eventsauce4j&lt;/groupId&gt;\n    &lt;artifactId&gt;eventsauce4j-rabbitmq-starter&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"getting-started/#22-enable-the-starter","title":"2.2 Enable the starter","text":"<pre><code>import io.eventsauce4j.starter.rabbitmq.EnableRabbitMqEventSauce4j;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@EnableRabbitMqEventSauce4j\npublic class Config {\n\n  @Bean\n  Inflector inflection() {\n    return new ChainInflector(List.of(\n      new ExternalInflector(\"io.eventsauce4j.example.domain.event.external\"),\n      new AnnotationInflector(UserCreated.class.getPackageName()),\n      new StaticInflector(Map.of(\n        EmailSent.class.getName(), EmailSent.class\n      ))\n    ));\n  }\n}\n</code></pre>"},{"location":"getting-started/#3-start-rabbitmq-for-rabbitmq-starter","title":"3) Start RabbitMQ (for RabbitMQ starter)","text":"<p>Run a local broker with Docker:</p> <pre><code>docker run -d --name rabbitmq \\\n  -p 5672:5672 -p 15672:15672 \\\n  -e RABBITMQ_DEFAULT_USER=guest \\\n  -e RABBITMQ_DEFAULT_PASS=guest \\\n  rabbitmq:3.13-management\n</code></pre> <p>Management UI: http://localhost:15672 (user/pass guest).</p>"},{"location":"getting-started/#4-configuration","title":"4) Configuration","text":"<p>RabbitMQ settings (application.yml)</p> <pre><code>eventsauce4j:\n  rabbitmq:\n    host: localhost\n    port: 5672\n    username: guest\n    password: guest\n    exchange: eventsauce4j.exchange\n    routingKey: eventsauce4j.key\n</code></pre>"},{"location":"getting-started/#outbox-settings","title":"Outbox settings","text":"<p>Use Spring properties to tune outbox publishing:</p> <p><code>eventsauce4j.outbox.delayInterval</code> : delay between outbox publish cycles</p> <p><code>eventsauce4j.outbox.lockName</code> : lock name to isolate publishers per service</p> <p>Example:</p> <pre><code>eventsauce4j:\n  outbox:\n    delayInterval: 5 #seconds\n    lockName: user-service-outbox-lock\n</code></pre>"},{"location":"getting-started/#working-example","title":"Working Example","text":"<p>See eventsauce4j-example: two Spring Boot services (user-service and payment-service) demonstrating JPA outbox + RabbitMQ messaging and shared event mappings.</p>"}]}